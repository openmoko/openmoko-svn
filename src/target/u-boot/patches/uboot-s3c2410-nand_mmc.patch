This patch adds boot-from-NAND and MMC support to the S3C2410 SoC code in
u-boot

Signed-off-by: Harald Welte <laforge@openmoko.org>

Index: u-boot/cpu/arm920t/s3c24x0/Makefile
===================================================================
--- u-boot.orig/cpu/arm920t/s3c24x0/Makefile	2007-02-08 14:33:31.000000000 +0100
+++ u-boot/cpu/arm920t/s3c24x0/Makefile	2007-02-08 14:45:09.000000000 +0100
@@ -26,7 +26,7 @@
 LIB	= $(obj)lib$(SOC).a
 
 COBJS	= i2c.o interrupts.o serial.o speed.o \
-	  usb_ohci.o
+	  usb_ohci.o mmc.o nand_read.o nand.o
 
 SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
Index: u-boot/cpu/arm920t/s3c24x0/mmc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ u-boot/cpu/arm920t/s3c24x0/mmc.c	2007-02-08 14:45:09.000000000 +0100
@@ -0,0 +1,569 @@
+/*
+ * u-boot S3C2410 MMC/SD card driver
+ * (C) Copyright 2006 by OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ * based on u-boot pxa MMC driver and linux/drivers/mmc/s3c2410mci.c
+ * (C) 2005-2005 Thomas Kleffel
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <mmc.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <s3c2410.h>
+#include <part.h>
+
+#ifdef CONFIG_MMC
+
+#define CONFIG_MMC_WIDE
+
+//#define MMC_DEBUG
+
+#ifdef MMC_DEBUG
+#ifdef debug
+#undef debug
+#endif
+#define debug printf
+#endif
+
+static S3C2410_SDI *sdi;
+
+extern int
+fat_register_device(block_dev_desc_t *dev_desc, int part_no);
+
+static block_dev_desc_t mmc_dev;
+
+block_dev_desc_t * mmc_get_dev(int dev)
+{
+	return ((block_dev_desc_t *)&mmc_dev);
+}
+
+/*
+ * FIXME needs to read cid and csd info to determine block size
+ * and other parameters
+ */
+static uchar mmc_buf[MMC_BLOCK_SIZE];
+static mmc_csd_t mmc_csd;
+static int mmc_ready = 0;
+static int wide = 0;
+
+
+#define CMD_F_RESP	0x01
+#define CMD_F_RESP_LONG	0x02
+
+static u_int32_t *
+/****************************************************/
+mmc_cmd(ushort cmd, ulong arg, ushort flags)
+/****************************************************/
+{
+	static u_int32_t resp[5];
+	ulong status;
+	int i;
+
+	u_int32_t ccon, csta;
+	u_int32_t csta_rdy_bit = S3C2410_SDICMDSTAT_CMDSENT;
+
+	memset(resp, 0, sizeof(resp));
+
+	debug("mmc_cmd CMD%d arg=0x%08x flags=%x\n", cmd, arg, flags);
+
+	sdi->SDICSTA = 0xffffffff;
+	sdi->SDIDSTA = 0xffffffff;
+	sdi->SDIFSTA = 0xffffffff;
+
+	sdi->SDICARG = arg;
+
+	ccon = cmd & S3C2410_SDICMDCON_INDEX;
+	ccon |= S3C2410_SDICMDCON_SENDERHOST|S3C2410_SDICMDCON_CMDSTART;
+	
+	if (flags & CMD_F_RESP) {
+		ccon |= S3C2410_SDICMDCON_WAITRSP;
+		csta_rdy_bit = S3C2410_SDICMDSTAT_RSPFIN; /* 1 << 9 */
+	}
+
+	if (flags & CMD_F_RESP_LONG)
+		ccon |= S3C2410_SDICMDCON_LONGRSP;
+
+	sdi->SDICCON = ccon;
+
+	while (1) {
+		csta = sdi->SDICSTA;
+		if (csta & csta_rdy_bit)
+			break;
+		if (csta & S3C2410_SDICMDSTAT_CMDTIMEOUT) {
+			printf("===============> MMC CMD Timeout\n");
+			sdi->SDICSTA |= S3C2410_SDICMDSTAT_CMDTIMEOUT;
+			break;
+		}
+	}
+
+	debug("final MMC CMD status 0x%x\n", csta);
+
+	sdi->SDICSTA |= csta_rdy_bit;
+
+	if (flags & CMD_F_RESP) {
+		resp[0] = sdi->SDIRSP0;
+		resp[1] = sdi->SDIRSP1;
+		resp[2] = sdi->SDIRSP2;
+		resp[3] = sdi->SDIRSP3;
+	} 
+
+#if 0
+	for (i=0; i<4; i ++) {
+		debug("MMC resp[%d] = 0x%08x\n", i, resp[i]);
+	}
+#endif
+
+	return resp;
+}
+
+#define FIFO_FILL(host) ((host->SDIFSTA & S3C2410_SDIFSTA_COUNTMASK) >> 2)
+
+static int
+/****************************************************/
+mmc_block_read(uchar *dst, ulong src, ulong len)
+/****************************************************/
+{
+	u_int32_t dcon, fifo;
+	u_int32_t *dst_u32 = (u_int32_t *)dst;
+	u_int32_t *resp;
+
+	if (len == 0) {
+		return 0;
+	}
+
+	debug("mmc_block_rd dst %lx src %lx len %d\n", (ulong)dst, src, len);
+
+	/* set block len */
+	resp = mmc_cmd(MMC_CMD_SET_BLOCKLEN, len, CMD_F_RESP);
+	sdi->SDIBSIZE = len;
+
+	//sdi->SDIPRE = 0xff;
+
+	/* setup data */
+	dcon = (len >> 9) & S3C2410_SDIDCON_BLKNUM_MASK;
+	dcon |= S3C2410_SDIDCON_BLOCKMODE;
+	dcon |= S3C2410_SDIDCON_RXAFTERCMD|S3C2410_SDIDCON_XFER_RXSTART;
+	if (wide)
+		dcon |= S3C2410_SDIDCON_WIDEBUS;
+	sdi->SDIDCON = dcon;
+
+	/* send read command */
+	resp = mmc_cmd(MMC_CMD_READ_BLOCK, src, CMD_F_RESP);
+
+	while (len > 0) {
+		u_int32_t sdidsta = sdi->SDIDSTA;
+		fifo = FIFO_FILL(sdi);
+		if (sdidsta & (S3C2410_SDIDSTA_FIFOFAIL|
+				S3C2410_SDIDSTA_CRCFAIL|
+				S3C2410_SDIDSTA_RXCRCFAIL|
+				S3C2410_SDIDSTA_DATATIMEOUT)) {
+			printf("mmc_block_read: err SDIDSTA=0x%08x\n", sdidsta);
+			return -EIO;
+		}
+
+		while (fifo--) {
+			//debug("dst_u32 = 0x%08x\n", dst_u32);
+			*(dst_u32++) = sdi->SDIDAT;
+			if (len >= 4)
+				len -= 4;
+			else {
+				len = 0;
+				break;
+			}
+		}
+	}
+
+#if 1
+	debug("waiting for SDIDSTA  (currently 0x%08x\n", sdi->SDIDSTA);
+	while (!(sdi->SDIDSTA & (1 << 4))) {}
+	debug("done waiting for SDIDSTA (currently 0x%08x\n", sdi->SDIDSTA);
+#endif
+
+	sdi->SDIDCON = 0;
+
+#if 0
+	if (!(sdi->SDIDSTA & S3C2410_SDIDSTA_XFERFINISH))
+		printf("mmc_block_read; transfer not finished!\n");
+#endif
+
+	return 0;
+}
+
+static int
+/****************************************************/
+mmc_block_write(ulong dst, uchar *src, int len)
+/****************************************************/
+{
+#if 0
+	uchar *resp;
+	ushort argh, argl;
+	ulong status;
+
+	if (len == 0) {
+		return 0;
+	}
+
+	debug("mmc_block_wr dst %lx src %lx len %d\n", dst, (ulong)src, len);
+
+	argh = len >> 16;
+	argl = len & 0xffff;
+
+	/* set block len */
+	resp = mmc_cmd(MMC_CMD_SET_BLOCKLEN, argh, argl, CMD_F_RESP);
+
+	/* send write command */
+	argh = dst >> 16;
+	argl = dst & 0xffff;
+	MMC_STRPCL = MMC_STRPCL_STOP_CLK;
+	MMC_NOB = 1;
+	MMC_BLKLEN = len;
+	resp = mmc_cmd(MMC_CMD_WRITE_BLOCK, dst, CMD_F_RESP,
+			MMC_CMDAT_R1|MMC_CMDAT_WRITE|MMC_CMDAT_BLOCK|MMC_CMDAT_DATA_EN);
+
+	MMC_I_MASK = ~MMC_I_MASK_TXFIFO_WR_REQ;
+	while (len) {
+		if (MMC_I_REG & MMC_I_REG_TXFIFO_WR_REQ) {
+			int i, bytes = min(32,len);
+
+			for (i=0; i<bytes; i++) {
+				MMC_TXFIFO = *src++;
+			}
+			if (bytes < 32) {
+				MMC_PRTBUF = MMC_PRTBUF_BUF_PART_FULL;
+			}
+			len -= bytes;
+		}
+		status = MMC_STAT;
+		if (status & MMC_STAT_ERRORS) {
+			printf("MMC_STAT error %lx\n", status);
+			return -1;
+		}
+	}
+	MMC_I_MASK = ~MMC_I_MASK_DATA_TRAN_DONE;
+	while (!(MMC_I_REG & MMC_I_REG_DATA_TRAN_DONE));
+	MMC_I_MASK = ~MMC_I_MASK_PRG_DONE;
+	while (!(MMC_I_REG & MMC_I_REG_PRG_DONE));
+	status = MMC_STAT;
+	if (status & MMC_STAT_ERRORS) {
+		printf("MMC_STAT error %lx\n", status);
+		return -1;
+	}
+#endif
+	return 0;
+}
+
+
+int
+/****************************************************/
+mmc_read(ulong src, uchar *dst, int size)
+/****************************************************/
+{
+	ulong end, part_start, part_end, part_len, aligned_start, aligned_end;
+	ulong mmc_block_size, mmc_block_address;
+
+	if (size == 0) {
+		return 0;
+	}
+
+	if (!mmc_ready) {
+		printf("Please initialize the MMC first\n");
+		return -1;
+	}
+
+	mmc_block_size = MMC_BLOCK_SIZE;
+	mmc_block_address = ~(mmc_block_size - 1);
+
+	src -= CFG_MMC_BASE;
+	end = src + size;
+	part_start = ~mmc_block_address & src;
+	part_end = ~mmc_block_address & end;
+	aligned_start = mmc_block_address & src;
+	aligned_end = mmc_block_address & end;
+
+	/* all block aligned accesses */
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_start) {
+		part_len = mmc_block_size - part_start;
+		debug("ps src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_start, mmc_block_size)) < 0) {
+			return -1;
+		}
+		memcpy(dst, mmc_buf+part_start, part_len);
+		dst += part_len;
+		src += part_len;
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	for (; src < aligned_end; src += mmc_block_size, dst += mmc_block_size) {
+		debug("al src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read((uchar *)(dst), src, mmc_block_size)) < 0) {
+			return -1;
+		}
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_end && src < end) {
+		debug("pe src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_end, mmc_block_size)) < 0) {
+			return -1;
+		}
+		memcpy(dst, mmc_buf, part_end);
+	}
+	return 0;
+}
+
+int
+/****************************************************/
+mmc_write(uchar *src, ulong dst, int size)
+/****************************************************/
+{
+	ulong end, part_start, part_end, part_len, aligned_start, aligned_end;
+	ulong mmc_block_size, mmc_block_address;
+
+	if (size == 0) {
+		return 0;
+	}
+
+	if (!mmc_ready) {
+		printf("Please initialize the MMC first\n");
+		return -1;
+	}
+
+	mmc_block_size = MMC_BLOCK_SIZE;
+	mmc_block_address = ~(mmc_block_size - 1);
+
+	dst -= CFG_MMC_BASE;
+	end = dst + size;
+	part_start = ~mmc_block_address & dst;
+	part_end = ~mmc_block_address & end;
+	aligned_start = mmc_block_address & dst;
+	aligned_end = mmc_block_address & end;
+
+	/* all block aligned accesses */
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_start) {
+		part_len = mmc_block_size - part_start;
+		debug("ps src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		(ulong)src, dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_start, mmc_block_size)) < 0) {
+			return -1;
+		}
+		memcpy(mmc_buf+part_start, src, part_len);
+		if ((mmc_block_write(aligned_start, mmc_buf, mmc_block_size)) < 0) {
+			return -1;
+		}
+		dst += part_len;
+		src += part_len;
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	for (; dst < aligned_end; src += mmc_block_size, dst += mmc_block_size) {
+		debug("al src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_write(dst, (uchar *)src, mmc_block_size)) < 0) {
+			return -1;
+		}
+	}
+	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+	if (part_end && dst < end) {
+		debug("pe src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
+		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
+		if ((mmc_block_read(mmc_buf, aligned_end, mmc_block_size)) < 0) {
+			return -1;
+		}
+		memcpy(mmc_buf, src, part_end);
+		if ((mmc_block_write(aligned_end, mmc_buf, mmc_block_size)) < 0) {
+			return -1;
+		}
+	}
+	return 0;
+}
+
+ulong
+/****************************************************/
+mmc_bread(int dev_num, ulong blknr, ulong blkcnt, ulong *dst)
+/****************************************************/
+{
+	int mmc_block_size = MMC_BLOCK_SIZE;
+	ulong src = blknr * mmc_block_size + CFG_MMC_BASE;
+
+	mmc_read(src, (uchar *)dst, blkcnt*mmc_block_size);
+	return blkcnt;
+}
+
+static u_int16_t rca = MMC_DEFAULT_RCA;
+
+static u_int32_t mmc_size(const struct mmc_csd *csd)
+{
+	u_int32_t block_len, mult, blocknr;
+
+	block_len = csd->read_bl_len << 12;
+	mult = csd->c_size_mult1 << 8;
+	blocknr = (csd->c_size+1) * mult;
+
+	return blocknr * block_len;
+}
+
+int
+/****************************************************/
+mmc_init(int verbose)
+/****************************************************/
+{
+ 	int retries, rc = -ENODEV;
+	int is_sd = 0;
+	u_int32_t *resp;
+	S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+	
+	sdi = S3C2410_GetBase_SDI();
+
+	debug("mmc_init(PCLK=%u)\n", get_PCLK());
+
+	clk_power->CLKCON |= (1 << 9);
+
+	/* S3C2410 has some bug that prevents reliable operation at higher speed */
+	//sdi->SDIPRE = 0x3e;  /* SDCLK = PCLK/2 / (SDIPRE+1) = 396kHz */
+	sdi->SDIPRE = 0x02;  /* SDCLK = PCLK/2 / (SDIPRE+1) = 396kHz */
+	sdi->SDIBSIZE = 512;
+	sdi->SDIDTIMER = 0xffff;
+	sdi->SDIIMSK = 0x0;
+	sdi->SDICON = S3C2410_SDICON_FIFORESET|S3C2440_SDICON_MMCCLOCK;
+	udelay(125000); /* FIXME: 74 SDCLK cycles */
+
+	mmc_csd.c_size = 0;
+
+	/* reset */
+	retries = 10;
+	resp = mmc_cmd(MMC_CMD_RESET, 0, 0);
+
+	printf("trying to detect SD Card...\n");
+	while (retries--) {
+		int i;
+		udelay(100000);
+		resp = mmc_cmd(55, 0x00000000, CMD_F_RESP);
+		resp = mmc_cmd(41, 0x00300000, CMD_F_RESP);
+
+		if (resp[0] & (1 << 31)) {
+			is_sd = 1;
+			break;
+		}
+	}
+
+	if (retries == 0 && !is_sd) {
+		retries = 10;
+		printf("failed to detect SD Card, trying MMC\n");
+		resp = mmc_cmd(MMC_CMD_SEND_OP_COND, 0x00ffc000, CMD_F_RESP);
+		while (retries-- && resp && !(resp[4] & 0x80)) {
+			debug("resp %x %x\n", resp[0], resp[1]);
+			udelay(50);
+			resp = mmc_cmd(1, 0x00ffff00, CMD_F_RESP);
+		}
+	}
+
+	/* try to get card id */
+	resp = mmc_cmd(MMC_CMD_ALL_SEND_CID, 0, CMD_F_RESP|CMD_F_RESP_LONG);
+	if (resp) {
+		/* TODO configure mmc driver depending on card attributes */
+		mmc_cid_t *cid = (mmc_cid_t *)resp;
+		if (verbose) {
+			printf("MMC found. Card desciption is:\n");
+			printf("Manufacturer ID = %02x%02x%02x\n",
+							cid->id[0], cid->id[1], cid->id[2]);
+			printf("HW/FW Revision = %x %x\n",cid->hwrev, cid->fwrev);
+			cid->hwrev = cid->fwrev = 0;	/* null terminate string */
+			printf("Product Name = %s\n",cid->name);
+			printf("Serial Number = %02x%02x%02x\n",
+							cid->sn[0], cid->sn[1], cid->sn[2]);
+			printf("Month = %d\n",cid->month);
+			printf("Year = %d\n",1997 + cid->year);
+		}
+		/* fill in device description */
+		mmc_dev.if_type = IF_TYPE_MMC;
+		mmc_dev.part_type = PART_TYPE_DOS;
+		mmc_dev.dev = 0;
+		mmc_dev.lun = 0;
+		mmc_dev.type = 0;
+		/* FIXME fill in the correct size (is set to 32MByte) */
+		mmc_dev.blksz = 512;
+		mmc_dev.lba = 0x10000;
+		sprintf(mmc_dev.vendor,"Man %02x%02x%02x Snr %02x%02x%02x",
+				cid->id[0], cid->id[1], cid->id[2],
+				cid->sn[0], cid->sn[1], cid->sn[2]);
+		sprintf(mmc_dev.product,"%s",cid->name);
+		sprintf(mmc_dev.revision,"%x %x",cid->hwrev, cid->fwrev);
+		mmc_dev.removable = 0;
+		mmc_dev.block_read = mmc_bread;
+
+		/* MMC exists, get CSD too */
+		resp = mmc_cmd(MMC_CMD_SET_RCA, MMC_DEFAULT_RCA, CMD_F_RESP);
+		if (is_sd)
+			rca = resp[0] >> 16;
+			
+		resp = mmc_cmd(MMC_CMD_SEND_CSD, rca<<16, CMD_F_RESP|CMD_F_RESP_LONG);
+		if (resp) {
+			mmc_csd_t *csd = (mmc_csd_t *)resp;
+			memcpy(&mmc_csd, csd, sizeof(csd));
+			rc = 0;
+			mmc_ready = 1;
+			/* FIXME add verbose printout for csd */
+			printf("READ_BL_LEN=%u, C_SIZE_MULT=%u, C_SIZE=%u\n", 
+				csd->read_bl_len, csd->c_size_mult1, csd->c_size);
+			printf("size = %u\n", mmc_size(csd));
+		}
+	}
+
+	resp = mmc_cmd(MMC_CMD_SELECT_CARD, rca<<16, CMD_F_RESP);
+
+#ifdef CONFIG_MMC_WIDE
+	if (is_sd) {
+		resp = mmc_cmd(55, rca<<16, CMD_F_RESP);
+		resp = mmc_cmd(6, 0x02, CMD_F_RESP);
+		wide = 1;
+	}
+#endif
+
+	fat_register_device(&mmc_dev,1); /* partitions start counting with 1 */
+
+	return rc;
+}
+
+int
+mmc_ident(block_dev_desc_t *dev)
+{
+	return 0;
+}
+
+int
+mmc2info(ulong addr)
+{
+	/* FIXME hard codes to 32 MB device */
+	if (addr >= CFG_MMC_BASE && addr < CFG_MMC_BASE + 0x02000000) {
+		return 1;
+	}
+	return 0;
+}
+
+#endif	/* CONFIG_MMC */
Index: u-boot/cpu/arm920t/s3c24x0/nand.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ u-boot/cpu/arm920t/s3c24x0/nand.c	2007-02-08 20:50:24.000000000 +0100
@@ -0,0 +1,215 @@
+/*
+ * (C) Copyright 2006 OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#if 0
+#define DEBUGN	printf
+#else
+#define DEBUGN(x, args ...) {}
+#endif
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+#if !defined(CFG_NAND_LEGACY)
+
+#include <nand.h>
+#include <s3c2410.h>
+
+#define __REGb(x)	(*(volatile unsigned char *)(x))
+#define __REGi(x)	(*(volatile unsigned int *)(x))
+
+#define	NF_BASE		0x4e000000
+#define	NFCONF		__REGi(NF_BASE + 0x0)
+#define	NFCMD		__REGb(NF_BASE + 0x4)
+#define	NFADDR		__REGb(NF_BASE + 0x8)
+#define	NFDATA		__REGb(NF_BASE + 0xc)
+#define	NFSTAT		__REGb(NF_BASE + 0x10)
+
+#define S3C2410_NFCONF_EN          (1<<15)
+#define S3C2410_NFCONF_512BYTE     (1<<14)
+#define S3C2410_NFCONF_4STEP       (1<<13)
+#define S3C2410_NFCONF_INITECC     (1<<12)
+#define S3C2410_NFCONF_nFCE        (1<<11)
+#define S3C2410_NFCONF_TACLS(x)    ((x)<<8)
+#define S3C2410_NFCONF_TWRPH0(x)   ((x)<<4)
+#define S3C2410_NFCONF_TWRPH1(x)   ((x)<<0)
+
+static u16 s3c2410_read_word(struct mtd_info *mtd)
+{
+	unsigned char byte = 0;
+
+	printf("s3c2410_read_word: WARNING, this function is not implemented yet\n");
+	return byte;	
+}
+
+static void s3c2410_write_word(struct mtd_info *mtd, u16 word)
+{
+	printf("s3c2410_write_word: WARNING, this function is not implemented yet\n");
+}
+
+static void s3c2410_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	DEBUGN("hwcontrol(): 0x%02x: ", cmd);
+
+	switch (cmd) {
+	case NAND_CTL_SETNCE:
+		NFCONF &= ~S3C2410_NFCONF_nFCE;
+		DEBUGN("NFCONF=0x%08x\n", NFCONF);
+		break;
+	case NAND_CTL_CLRNCE:
+		NFCONF |= S3C2410_NFCONF_nFCE;
+		DEBUGN("NFCONF=0x%08x\n", NFCONF);
+		break;
+	case NAND_CTL_SETALE:
+		chip->IO_ADDR_W = NF_BASE + 0x8;
+		DEBUGN("SETALE\n");
+		break;
+	case NAND_CTL_SETCLE:
+		chip->IO_ADDR_W = NF_BASE + 0x4;
+		DEBUGN("SETCLE\n");
+		break;
+	default:
+		chip->IO_ADDR_W = NF_BASE + 0xc;
+		break;
+	}
+	return;
+}
+
+static int s3c2410_dev_ready(struct mtd_info *mtd)
+{
+	DEBUGN("dev_ready\n");
+	return (NFSTAT & 0x01);
+}
+
+static void s3c2410_cmdfunc(struct mtd_info *mtd, unsigned cmd,
+			    int column, int page_addr)
+{
+	DEBUGN("cmdfunc(): 0x%02x, col=%d, page=%d\n", cmd, column, page_addr);
+
+	switch (cmd) {
+	case NAND_CMD_READ0:
+	case NAND_CMD_READ1:
+	case NAND_CMD_READOOB:
+		NFCMD = cmd;
+		NFADDR = column & 0xff;
+		NFADDR = page_addr & 0xff;
+		NFADDR = (page_addr >> 8) & 0xff;
+		NFADDR = (page_addr >> 16) & 0xff;
+		break;
+	case NAND_CMD_READID:
+		NFCMD = cmd;
+		NFADDR = 0;
+		break;
+	case NAND_CMD_PAGEPROG:
+		NFCMD = cmd;
+		printf("PAGEPROG not implemented\n");
+		break;
+	case NAND_CMD_ERASE1:
+		NFCMD = cmd;
+		NFADDR = page_addr & 0xff;
+		NFADDR = (page_addr >> 8) & 0xff;
+		NFADDR = (page_addr >> 16) & 0xff;
+		break;
+	case NAND_CMD_ERASE2:
+		NFCMD = cmd;
+		break;
+	case NAND_CMD_SEQIN:
+		printf("SEQIN not implemented\n");
+		break;
+	case NAND_CMD_STATUS:
+		NFCMD = cmd;
+		break;
+	case NAND_CMD_RESET:
+		NFCMD = cmd;
+		break;
+	default:
+		break;
+	}
+
+	while (!s3c2410_dev_ready(mtd));
+}
+
+int board_nand_init(struct nand_chip *nand)
+{
+	u_int32_t cfg;
+	u_int8_t tacls, twrph0, twrph1;
+	S3C24X0_CLOCK_POWER * const clk_power = S3C24X0_GetBase_CLOCK_POWER();
+
+	DEBUGN("board_nand_init()\n");
+
+	clk_power->CLKCON |= (1 << 4);
+
+	/* initialize hardware */
+	twrph0 = 3; twrph1 = 0; tacls = 0;
+
+	/* default timings: maximum */
+	//twrph0 = 8; twrph1 = 8; tacls = 8;
+
+	cfg = S3C2410_NFCONF_EN;
+	cfg |= S3C2410_NFCONF_TACLS(tacls - 1);
+	cfg |= S3C2410_NFCONF_TWRPH0(twrph0 - 1);
+	cfg |= S3C2410_NFCONF_TWRPH1(twrph1 - 1);
+
+	//NFCONF = cfg;
+	NFCONF = 0xf842;
+
+	/* initialize nand_chip data structure */
+	nand->IO_ADDR_R = nand->IO_ADDR_W = 0x4e00000c;
+
+	/* read_buf and write_buf are default */
+	/* read_byte and write_byte are default */
+
+	/* need to override word read/write since default routines try 16bit wide
+	 * register access of an (in our case) 8bit register */
+	nand->read_word = s3c2410_read_word;
+	nand->write_word = s3c2410_write_word;
+
+	/* hwcontrol always must be implemented */
+	nand->hwcontrol = s3c2410_hwcontrol;
+
+	nand->dev_ready = s3c2410_dev_ready;
+
+	nand->eccmode = NAND_ECC_SOFT;
+	nand->options = 0;
+	//nand->waitfunc = dfc_wait;
+
+	//nand->cmdfunc = s3c2410_cmdfunc;
+	//nand->autooob = &delta_oob;
+	//nand->badblock_pattern = &delta_bbt_descr;
+	
+#if 0
+	/* reset */
+	nand->hwcontrol(NULL, NAND_CTL_SETNCE);
+	nand->cmdfunc(NULL, NAND_CMD_RESET, -1, -1);
+	while (nand->dev_ready(NULL) == 0) {}
+	nand->hwcontrol(NULL, NAND_CTL_CLRNCE);
+#endif
+
+	DEBUGN("end of nand_init\n");
+
+	return 0;
+}
+
+#else
+ #error "U-Boot legacy NAND support not available for S3C2410"
+#endif
+#endif
Index: u-boot/cpu/arm920t/s3c24x0/nand_read.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ u-boot/cpu/arm920t/s3c24x0/nand_read.c	2007-02-08 20:49:01.000000000 +0100
@@ -0,0 +1,76 @@
+/* 
+ * nand_read.c: Simple NAND read functions for booting from NAND
+ *
+ * Taken from GPLv2 licensed vivi bootloader,
+ * Copyright (C) 2002 MIZI Research, Inc.
+ *
+ * Author: Hwang, Chideok <hwang@mizi.com>
+ * Date  : $Date: 2004/02/04 10:37:37 $
+ *
+ * u-boot integration (C) 2006 by OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ */
+
+#include <common.h>
+
+#ifdef CONFIG_S3C2410_NAND_BOOT
+
+#define __REGb(x)	(*(volatile unsigned char *)(x))
+#define __REGi(x)	(*(volatile unsigned int *)(x))
+#define NF_BASE		0x4e000000
+#define NFCONF		__REGi(NF_BASE + 0x0)
+#define NFCMD		__REGb(NF_BASE + 0x4)
+#define NFADDR		__REGb(NF_BASE + 0x8)
+#define NFDATA		__REGb(NF_BASE + 0xc)
+#define NFSTAT		__REGb(NF_BASE + 0x10)
+
+#define BUSY 1
+inline void wait_idle(void) {
+    int i;
+
+    while(!(NFSTAT & BUSY))
+      for(i=0; i<10; i++);
+}
+
+#define NAND_SECTOR_SIZE	512
+#define NAND_BLOCK_MASK		(NAND_SECTOR_SIZE - 1)
+
+/* low level nand read function */
+int
+nand_read_ll(unsigned char *buf, unsigned long start_addr, int size)
+{
+    int i, j;
+
+    if ((start_addr & NAND_BLOCK_MASK) || (size & NAND_BLOCK_MASK)) {
+        return -1;	/* invalid alignment */
+    }
+
+    /* chip Enable */
+    NFCONF &= ~0x800;
+    for(i=0; i<10; i++);
+
+    for(i=start_addr; i < (start_addr + size);) {
+      /* READ0 */
+      NFCMD = 0;
+
+      /* Write Address */
+      NFADDR = i & 0xff;
+      NFADDR = (i >> 9) & 0xff;
+      NFADDR = (i >> 17) & 0xff;
+      NFADDR = (i >> 25) & 0xff;
+
+      wait_idle();
+
+      for(j=0; j < NAND_SECTOR_SIZE; j++, i++) {
+	*buf = (NFDATA & 0xff);
+	buf++;
+      }
+    }
+
+    /* chip Disable */
+    NFCONF |= 0x800;	/* chip disable */
+
+    return 0;
+}
+
+#endif /* CONFIG_S3C2410_NAND_BOOT */
Index: u-boot/cpu/arm920t/start.S
===================================================================
--- u-boot.orig/cpu/arm920t/start.S	2007-02-08 14:33:32.000000000 +0100
+++ u-boot/cpu/arm920t/start.S	2007-02-08 20:48:51.000000000 +0100
@@ -5,6 +5,10 @@
  *  Copyright (c) 2002	Alex Züpke <azu@sysgo.de>
  *  Copyright (c) 2002	Gary Jennejohn <gj@denx.de>
  *
+ * S3C2410 NAND portions
+ *  Copyright (c) 2001  MIZI Research, Inc.
+ *  Copyright (c) 2006  OpenMoko, Inc. (Harald Welte <laforge@openmmoko.org>
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -27,6 +31,7 @@
 
 #include <config.h>
 #include <version.h>
+#include <s3c2410.h>
 
 
 /*
@@ -158,9 +163,17 @@
 	 */
 #ifndef CONFIG_SKIP_LOWLEVEL_INIT
 	bl	cpu_init_crit
+#else
+	/* QT2410: configure bank 3 correctly to make ethernet work */
+	ldr	r1, =0x48000000
+	ldr	r2, =0x00001f4c
+	str	r2, [r1, #0x10]
+	ldr	r2, =0x2211d122
+	str	r2, [r1]
 #endif
 
 #ifndef CONFIG_SKIP_RELOCATE_UBOOT
+#ifndef CONFIG_S3C2410_NAND_BOOT
 relocate:				/* relocate U-Boot to RAM	    */
 	adr	r0, _start		/* r0 <- current position of code   */
 	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM */
@@ -177,6 +190,93 @@
 	stmia	r1!, {r3-r10}		/* copy to   target address [r1]    */
 	cmp	r0, r2			/* until source end addreee [r2]    */
 	ble	copy_loop
+#else /* NAND_BOOT */
+relocate:
+copy_myself:
+	/* mov	r10, lr */
+
+	@ reset NAND
+	mov	r1, #S3C2410_NAND_BASE
+	ldr	r2, =0xf842		@ initial value enable tacls=3,rph0=6,rph1=0
+	str	r2, [r1, #oNFCONF]
+	ldr	r2, [r1, #oNFCONF]
+	bic	r2, r2, #0x800		@ enable chip
+	str	r2, [r1, #oNFCONF]
+	mov	r2, #0xff		@ RESET command
+	strb	r2, [r1, #oNFCMD]
+	mov	r3, #0			@ wait 
+1:	add	r3, r3, #0x1
+	cmp	r3, #0xa
+	blt	1b
+2:	ldr	r2, [r1, #oNFSTAT]	@ wait ready
+	tst	r2, #0x1
+	beq	2b
+	ldr	r2, [r1, #oNFCONF]
+	orr	r2, r2, #0x800		@ disable chip
+	str	r2, [r1, #oNFCONF]
+
+#if 0
+	@ get ready to call C functions (for nand_read())
+	ldr	sp, DW_STACK_START	@ setup stack pointer
+	mov	fp, #0			@ no previous frame, so fp=0
+#else
+	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
+	sub	r0, r0, #CFG_MALLOC_LEN	/* malloc area                      */
+	sub	r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo                        */
+#ifdef CONFIG_USE_IRQ
+	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)
+#endif
+	sub	sp, r0, #12		/* leave 3 words for abort-stack    */
+#endif
+
+	@ copy u-boot to RAM
+	ldr	r0, _TEXT_BASE
+	mov     r1, #0x0
+	mov	r2, #0x30000
+	bl	nand_read_ll
+
+	tst	r0, #0x0
+	beq	ok_nand_read
+#ifdef CONFIG_DEBUG_LL
+bad_nand_read: 
+	ldr	r0, STR_FAIL
+	ldr	r1, SerBase
+	bl	PrintWord
+1:	b	1b		@ infinite loop 
+#endif
+	
+ok_nand_read:
+#ifdef CONFIG_DEBUG_LL
+	ldr	r0, STR_OK
+	ldr	r1, SerBase
+	bl	PrintWord
+#endif
+
+	@ verify
+	mov	r0, #0
+	@ldr	r1, =0x33f00000
+	ldr	r1, _TEXT_BASE
+	mov	r2, #0x400	@ 4 bytes * 1024 = 4K-bytes
+go_next:
+	ldr	r3, [r0], #4
+	ldr	r4, [r1], #4
+	teq	r3, r4
+	bne	notmatch
+	subs	r2, r2, #4
+	beq	done_nand_read	
+	bne	go_next
+notmatch:
+#ifdef CONFIG_DEBUG_LL
+	sub	r0, r0, #4
+	ldr	r1, SerBase
+	bl	PrintHexWord
+	ldr	r0, STR_FAIL
+	ldr	r1, SerBase
+	bl	PrintWord
+#endif
+1:	b	1b
+done_nand_read:
+#endif /* NAND_BOOT */
 #endif	/* CONFIG_SKIP_RELOCATE_UBOOT */
 
 	/* Set up the stack						    */
Index: u-boot/include/asm-arm/arch-s3c24x0/mmc.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ u-boot/include/asm-arm/arch-s3c24x0/mmc.h	2007-02-08 14:45:09.000000000 +0100
@@ -0,0 +1,112 @@
+/*
+ *  linux/drivers/mmc/mmc_pxa.h
+ *
+ *  Author: Vladimir Shebordaev, Igor Oblakov
+ *  Copyright:  MontaVista Software Inc.
+ *
+ *  $Id: mmc_pxa.h,v 0.3.1.6 2002/09/25 19:25:48 ted Exp ted $
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+#ifndef __MMC_PXA_P_H__
+#define __MMC_PXA_P_H__
+
+#include <asm/arch/regs-sdi.h>
+
+#define MMC_DEFAULT_RCA			(1<<16)
+
+#define MMC_BLOCK_SIZE			512
+#define MMC_CMD_RESET			0
+#define MMC_CMD_SEND_OP_COND		1
+#define MMC_CMD_ALL_SEND_CID 		2
+#define MMC_CMD_SET_RCA			3
+#define MMC_CMD_SELECT_CARD		7
+#define MMC_CMD_SEND_CSD 		9
+#define MMC_CMD_SEND_CID 		10
+#define MMC_CMD_SEND_STATUS		13
+#define MMC_CMD_SET_BLOCKLEN		16
+#define MMC_CMD_READ_BLOCK		17
+#define MMC_CMD_RD_BLK_MULTI		18
+#define MMC_CMD_WRITE_BLOCK		24
+
+#define MMC_MAX_BLOCK_SIZE		512
+
+#define MMC_R1_IDLE_STATE		0x01
+#define MMC_R1_ERASE_STATE		0x02
+#define MMC_R1_ILLEGAL_CMD		0x04
+#define MMC_R1_COM_CRC_ERR		0x08
+#define MMC_R1_ERASE_SEQ_ERR		0x01
+#define MMC_R1_ADDR_ERR			0x02
+#define MMC_R1_PARAM_ERR		0x04
+
+#define MMC_R1B_WP_ERASE_SKIP		0x0002
+#define MMC_R1B_ERR			0x0004
+#define MMC_R1B_CC_ERR			0x0008
+#define MMC_R1B_CARD_ECC_ERR		0x0010
+#define MMC_R1B_WP_VIOLATION		0x0020
+#define MMC_R1B_ERASE_PARAM		0x0040
+#define MMC_R1B_OOR			0x0080
+#define MMC_R1B_IDLE_STATE		0x0100
+#define MMC_R1B_ERASE_RESET		0x0200
+#define MMC_R1B_ILLEGAL_CMD		0x0400
+#define MMC_R1B_COM_CRC_ERR		0x0800
+#define MMC_R1B_ERASE_SEQ_ERR		0x1000
+#define MMC_R1B_ADDR_ERR		0x2000
+#define MMC_R1B_PARAM_ERR		0x4000
+
+typedef struct mmc_cid
+{
+/* FIXME: BYTE_ORDER */
+   uchar year:4,
+   month:4;
+   uchar sn[3];
+   uchar fwrev:4,
+   hwrev:4;
+   uchar name[6];
+   uchar id[3];
+} mmc_cid_t;
+
+typedef struct mmc_csd
+{
+	uchar	ecc:2,
+		file_format:2,
+		tmp_write_protect:1,
+		perm_write_protect:1,
+		copy:1,
+		file_format_grp:1;
+	uint64_t content_prot_app:1,
+		rsvd3:4,
+		write_bl_partial:1,
+		write_bl_len:4,
+		r2w_factor:3,
+		default_ecc:2,
+		wp_grp_enable:1,
+		wp_grp_size:5,
+		erase_grp_mult:5,
+		erase_grp_size:5,
+		c_size_mult1:3,
+		vdd_w_curr_max:3,
+		vdd_w_curr_min:3,
+		vdd_r_curr_max:3,
+		vdd_r_curr_min:3,
+		c_size:12,
+		rsvd2:2,
+		dsr_imp:1,
+		read_blk_misalign:1,
+		write_blk_misalign:1,
+		read_bl_partial:1;
+
+	ushort	read_bl_len:4,
+		ccc:12;
+	uchar	tran_speed;
+	uchar	nsac;
+	uchar	taac;
+	uchar	rsvd1:2,
+  		spec_vers:4,
+		csd_structure:2;
+} mmc_csd_t;
+
+
+#endif /* __MMC_PXA_P_H__ */
Index: u-boot/include/asm-arm/arch-s3c24x0/regs-sdi.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ u-boot/include/asm-arm/arch-s3c24x0/regs-sdi.h	2007-02-08 14:45:09.000000000 +0100
@@ -0,0 +1,110 @@
+/* linux/include/asm/arch-s3c2410/regs-sdi.h
+ *
+ * Copyright (c) 2004 Simtec Electronics <linux@simtec.co.uk>
+ *		      http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2410 MMC/SDIO register definitions
+ *
+ *  Changelog:
+ *    18-Aug-2004 Ben Dooks      Created initial file
+ *    29-Nov-2004 Koen Martens   Added some missing defines, fixed duplicates
+ *    29-Nov-2004 Ben Dooks	 Updated Koen's patch
+*/
+
+#ifndef __ASM_ARM_REGS_SDI
+#define __ASM_ARM_REGS_SDI "regs-sdi.h"
+
+#define S3C2440_SDICON_SDRESET        (1<<8)
+#define S3C2440_SDICON_MMCCLOCK       (1<<5)
+#define S3C2410_SDICON_BYTEORDER      (1<<4)
+#define S3C2410_SDICON_SDIOIRQ        (1<<3)
+#define S3C2410_SDICON_RWAITEN        (1<<2)
+#define S3C2410_SDICON_FIFORESET      (1<<1)
+#define S3C2410_SDICON_CLOCKTYPE      (1<<0)
+
+#define S3C2410_SDICMDCON_ABORT       (1<<12)
+#define S3C2410_SDICMDCON_WITHDATA    (1<<11)
+#define S3C2410_SDICMDCON_LONGRSP     (1<<10)
+#define S3C2410_SDICMDCON_WAITRSP     (1<<9)
+#define S3C2410_SDICMDCON_CMDSTART    (1<<8)
+#define S3C2410_SDICMDCON_SENDERHOST  (1<<6)
+#define S3C2410_SDICMDCON_INDEX       (0x3f)
+
+#define S3C2410_SDICMDSTAT_CRCFAIL    (1<<12)
+#define S3C2410_SDICMDSTAT_CMDSENT    (1<<11)
+#define S3C2410_SDICMDSTAT_CMDTIMEOUT (1<<10)
+#define S3C2410_SDICMDSTAT_RSPFIN     (1<<9)
+#define S3C2410_SDICMDSTAT_XFERING    (1<<8)
+#define S3C2410_SDICMDSTAT_INDEX      (0xff)
+
+#define S3C2440_SDIDCON_DS_BYTE       (0<<22)
+#define S3C2440_SDIDCON_DS_HALFWORD   (1<<22)
+#define S3C2440_SDIDCON_DS_WORD       (2<<22)
+#define S3C2410_SDIDCON_IRQPERIOD     (1<<21)
+#define S3C2410_SDIDCON_TXAFTERRESP   (1<<20)
+#define S3C2410_SDIDCON_RXAFTERCMD    (1<<19)
+#define S3C2410_SDIDCON_BUSYAFTERCMD  (1<<18)
+#define S3C2410_SDIDCON_BLOCKMODE     (1<<17)
+#define S3C2410_SDIDCON_WIDEBUS       (1<<16)
+#define S3C2410_SDIDCON_DMAEN         (1<<15)
+#define S3C2410_SDIDCON_STOP          (1<<14)
+#define S3C2440_SDIDCON_DATSTART      (1<<14)
+#define S3C2410_SDIDCON_DATMODE	      (3<<12)
+#define S3C2410_SDIDCON_BLKNUM        (0x7ff)
+
+/* constants for S3C2410_SDIDCON_DATMODE */
+#define S3C2410_SDIDCON_XFER_READY    (0<<12)
+#define S3C2410_SDIDCON_XFER_CHKSTART (1<<12)
+#define S3C2410_SDIDCON_XFER_RXSTART  (2<<12)
+#define S3C2410_SDIDCON_XFER_TXSTART  (3<<12)
+
+#define S3C2410_SDIDCON_BLKNUM_MASK   (0xFFF)
+#define S3C2410_SDIDCNT_BLKNUM_SHIFT  (12)
+
+#define S3C2410_SDIDSTA_RDYWAITREQ    (1<<10)
+#define S3C2410_SDIDSTA_SDIOIRQDETECT (1<<9)
+#define S3C2410_SDIDSTA_FIFOFAIL      (1<<8)	/* reserved on 2440 */
+#define S3C2410_SDIDSTA_CRCFAIL       (1<<7)
+#define S3C2410_SDIDSTA_RXCRCFAIL     (1<<6)
+#define S3C2410_SDIDSTA_DATATIMEOUT   (1<<5)
+#define S3C2410_SDIDSTA_XFERFINISH    (1<<4)
+#define S3C2410_SDIDSTA_BUSYFINISH    (1<<3)
+#define S3C2410_SDIDSTA_SBITERR       (1<<2)	/* reserved on 2410a/2440 */
+#define S3C2410_SDIDSTA_TXDATAON      (1<<1)
+#define S3C2410_SDIDSTA_RXDATAON      (1<<0)
+
+#define S3C2440_SDIFSTA_FIFORESET      (1<<16)
+#define S3C2440_SDIFSTA_FIFOFAIL       (3<<14)  /* 3 is correct (2 bits) */
+#define S3C2410_SDIFSTA_TFDET          (1<<13)
+#define S3C2410_SDIFSTA_RFDET          (1<<12)
+#define S3C2410_SDIFSTA_TFHALF         (1<<11)
+#define S3C2410_SDIFSTA_TFEMPTY        (1<<10)
+#define S3C2410_SDIFSTA_RFLAST         (1<<9)
+#define S3C2410_SDIFSTA_RFFULL         (1<<8)
+#define S3C2410_SDIFSTA_RFHALF         (1<<7)
+#define S3C2410_SDIFSTA_COUNTMASK      (0x7f)
+
+#define S3C2410_SDIIMSK_RESPONSECRC    (1<<17)
+#define S3C2410_SDIIMSK_CMDSENT        (1<<16)
+#define S3C2410_SDIIMSK_CMDTIMEOUT     (1<<15)
+#define S3C2410_SDIIMSK_RESPONSEND     (1<<14)
+#define S3C2410_SDIIMSK_READWAIT       (1<<13)
+#define S3C2410_SDIIMSK_SDIOIRQ        (1<<12)
+#define S3C2410_SDIIMSK_FIFOFAIL       (1<<11)
+#define S3C2410_SDIIMSK_CRCSTATUS      (1<<10)
+#define S3C2410_SDIIMSK_DATACRC        (1<<9)
+#define S3C2410_SDIIMSK_DATATIMEOUT    (1<<8)
+#define S3C2410_SDIIMSK_DATAFINISH     (1<<7)
+#define S3C2410_SDIIMSK_BUSYFINISH     (1<<6)
+#define S3C2410_SDIIMSK_SBITERR        (1<<5)	/* reserved 2440/2410a */
+#define S3C2410_SDIIMSK_TXFIFOHALF     (1<<4)
+#define S3C2410_SDIIMSK_TXFIFOEMPTY    (1<<3)
+#define S3C2410_SDIIMSK_RXFIFOLAST     (1<<2)
+#define S3C2410_SDIIMSK_RXFIFOFULL     (1<<1)
+#define S3C2410_SDIIMSK_RXFIFOHALF     (1<<0)
+
+#endif /* __ASM_ARM_REGS_SDI */
Index: u-boot/include/s3c2410.h
===================================================================
--- u-boot.orig/include/s3c2410.h	2007-02-08 14:33:46.000000000 +0100
+++ u-boot/include/s3c2410.h	2007-02-08 20:48:49.000000000 +0100
@@ -38,12 +38,6 @@
 #define S3C2410_ECCSIZE		512
 #define S3C2410_ECCBYTES	3
 
-typedef enum {
-	S3C24X0_UART0,
-	S3C24X0_UART1,
-	S3C24X0_UART2
-} S3C24X0_UARTS_NR;
-
 /* S3C2410 device base addresses */
 #define S3C24X0_MEMCTL_BASE		0x48000000
 #define S3C24X0_USB_HOST_BASE		0x49000000
@@ -65,9 +59,23 @@
 #define S3C2410_SDI_BASE		0x5A000000
 
 
+#define oNFCONF			0x00
+#define oNFCMD			0x04
+#define oNFADDR			0x08
+#define oNFDATA			0x0C
+#define oNFSTAT			0x10
+#define oNFECC			0x14
+
+#ifndef __ASSEMBLER__
+
 /* include common stuff */
 #include <s3c24x0.h>
 
+typedef enum {
+	S3C24X0_UART0,
+	S3C24X0_UART1,
+	S3C24X0_UART2
+} S3C24X0_UARTS_NR;
 
 static inline S3C24X0_MEMCTL * const S3C24X0_GetBase_MEMCTL(void)
 {
@@ -142,6 +150,7 @@
 	return (S3C2410_SDI * const)S3C2410_SDI_BASE;
 }
 
+#endif
 
 /* ISR */
 #define pISR_RESET		(*(unsigned *)(_ISR_STARTADDRESS+0x0))
Index: u-boot/include/s3c24x0.h
===================================================================
--- u-boot.orig/include/s3c24x0.h	2007-02-08 14:33:46.000000000 +0100
+++ u-boot/include/s3c24x0.h	2007-02-08 14:45:09.000000000 +0100
@@ -637,13 +637,7 @@
 	S3C24X0_REG32	SDIDCNT;
 	S3C24X0_REG32	SDIDSTA;
 	S3C24X0_REG32	SDIFSTA;
-#ifdef __BIG_ENDIAN
-	S3C24X0_REG8	res[3];
-	S3C24X0_REG8	SDIDAT;
-#else
-	S3C24X0_REG8	SDIDAT;
-	S3C24X0_REG8	res[3];
-#endif
+	S3C24X0_REG32	SDIDAT;
 	S3C24X0_REG32	SDIIMSK;
 } /*__attribute__((__packed__))*/ S3C2410_SDI;
 
@@ -1123,11 +1117,7 @@
 #define rSDIDatCnt		(*(volatile unsigned *)0x5A000030)
 #define rSDIDatSta		(*(volatile unsigned *)0x5A000034)
 #define rSDIFSTA		(*(volatile unsigned *)0x5A000038)
-#ifdef __BIG_ENDIAN
-#define rSDIDAT			(*(volatile unsigned char *)0x5A00003F)
-#else
-#define rSDIDAT			(*(volatile unsigned char *)0x5A00003C)
-#endif
+#define rSDIDAT			(*(volatile unsigned *)0x5A00003C)
 #define rSDIIntMsk		(*(volatile unsigned *)0x5A000040)
 
 #endif
